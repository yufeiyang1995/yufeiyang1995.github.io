---
layout:     post
title:      深入理解JVM总结
category: blog
description: 总结JVM～
---

## 深入理解JVM总结

#### 1. 目录

* 内存区域


* 内存泄漏和内存溢出
* 类型擦除
* 对象创建，分配和访问
* GC的判定
* GC实现方法
* 类加载过程
* 双亲委派模型
* 分派
* GC收集器




#### 2. 内存区域

我们在Java开发时经常会遇到OutOfMemory的错误，那我们有时候会不清楚问题在哪里，需要花很大力气调试；我们在开发时需要设置JVM参数，那么，我们就只有在了解了JVM的内存结构之后，才能更好的帮助我们进行Java开发。

首先，JVM的内存结构主要分为三个最主要的部分：堆，方法区和栈，其中堆负责存放对象实例，是虚拟机内存中最大的一部分；方法区存储类信息、常量、静态变量等数据；栈分为java虚拟机栈和本地方法栈主要用于方法的执行。下面详细介绍一下JVM内存各部分的作用：

* 堆
  * 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中**最大**的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
  * 用途：
    * 存放对象实例，**几乎所有的对象实例都在这里分配内存**。
  * 垃圾收集：
    * Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“**GC堆**”。
    * 如果从内存回收的角度看，由于现在收集器基本都是采用的**分代收集算法**，所以Java堆中还可以细分为：**新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。**
    * 所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）
  * 物理上不连续，逻辑连续；可固定大小，也可扩展（通过-Xmx和-Xms控制）。
  * 异常情况：
    * 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
* 方法区
  * 与Java堆一样，是各个线程共享的内存区域
  * 用途：
    * 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  * 虽然规范中看作堆的逻辑部分，但被称为Non-heap
  * 性质：前两点与堆相同
    * 物理不连续，逻辑连续
    * 可扩展
    * 可以选择不实现垃圾收集
    * 内存回收目标主要是针对常量池的回收和对类型的卸载
  * 异常情况：
    * ​
* Java虚拟机栈
  * 线程私有的，生命周期与线程相同，与前两者有明显区别
  * 用途：
    * 记录方法执行的信息，每个方法在执行时会创建一个栈帧
    * 存储方法中的局部变量表、操作栈、动态链接、方法出口等信息
    * 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
  * 异常情况：
    * 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
    * 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
* 本地方法栈
  * 与虚拟机栈作用基本相同，只是面向本地方法进行栈帧的管理
  * 与虚拟机栈相同，会产生StackOverflowError和OutOfMemoryError异常
* 程序计数器
  * 一块较小的内存，线程私有
  * 用途：
    * 当前线程所执行的字节码的行号指示器
    * 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    * 为了线程切换，程序可以执行正确的指令，需要程序计数器来记录
  * **此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**
* 实例说明：

```java
import java.text.SimpleDataFormat;
import java.util.Date;
import org.apache.log4j.Logger;

public class HelloWorld{
    private static Logger LOGGER = Logger.getLogger(HelloWorld.class.getName());
    public void sayHello(String Hello){
        SimpleDataFormat formatter = new SimpleDataFormat("dd.MM.YYYY");
        String today = formatter.format(new Date());
        LOGGER.info(today + " : "+messeage);
    }
}
```

​	在上面的实例中，数据在内存中的存放如下：

| 内存位置 | 存放数据                                                     |
| -------- | ------------------------------------------------------------ |
| 堆       | Object: HelloWorld<br />Object: SimpleDataFormat<br />Object: String<br />Object:Logger |
| 方法区   | Class: HelloWorld<br />Class: Logger<br />Class: SimpleDataFormat |
| JVM栈    | Parameter Ref: String "message"<br />Variable Ref: formatter<br />local primitive: "lineNo" |