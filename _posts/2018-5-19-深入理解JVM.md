---
layout:     post
title:      深入理解JVM总结
category: blog
description: 总结JVM～
---

## 深入理解JVM总结

#### 1. 大概内容

* 内存区域


* 内存泄漏和内存溢出
* 类型擦除
* 对象创建，分配和访问
* GC的判定
* GC实现方法
* 类加载过程
* 双亲委派模型
* 分派
* GC收集器




#### 2. 内存结构介绍

我们在Java开发时经常会遇到OutOfMemory的错误，那我们有时候会不清楚问题在哪里，需要花很大力气调试；我们在开发时需要设置JVM参数，那么，我们就只有在了解了JVM的内存结构之后，才能更好的帮助我们进行Java开发。

首先，JVM的内存结构主要分为三个最主要的部分：堆，方法区和栈，其中堆负责存放对象实例，是虚拟机内存中最大的一部分；方法区存储类信息、常量、静态变量等数据；栈分为java虚拟机栈和本地方法栈主要用于方法的执行。下面详细介绍一下JVM内存各部分的作用：

* 堆
  * 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中**最大**的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。
  * 用途：
    * 存放对象实例，**几乎所有的对象实例都在这里分配内存**。
  * 垃圾收集：
    * Java堆是垃圾收集器管理的主要区域，因此很多时候也被称做“**GC堆**”。
    * 如果从内存回收的角度看，由于现在收集器基本都是采用的**分代收集算法**，所以Java堆中还可以细分为：**新生代和老年代；再细致一点的有Eden空间、From Survivor空间、To Survivor空间等。**
    * 所有的对象在实例化后的整个运行周期内，都被存放在堆内存中。堆内存又被划分成不同的部分：伊甸区(Eden)，幸存者区域(Survivor Sapce)，老年代（Old Generation Space）
  * 物理上不连续，逻辑连续；可固定大小，也可扩展（通过-Xmx和-Xms控制）。
  * 异常情况：
    * 如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。
* 方法区
  * 与Java堆一样，是各个线程共享的内存区域
  * 用途：
    * 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
  * 虽然规范中看作堆的逻辑部分，但被称为Non-heap
  * 性质：前两点与堆相同
    * 物理不连续，逻辑连续
    * 可扩展
    * 可以选择不实现垃圾收集
    * 内存回收目标主要是针对常量池的回收和对类型的卸载
  * 异常情况：
    * ​
* Java虚拟机栈
  * 线程私有的，生命周期与线程相同，与前两者有明显区别
  * 用途：
    * 记录方法执行的信息，每个方法在执行时会创建一个栈帧
    * 存储方法中的局部变量表、操作栈、动态链接、方法出口等信息
    * 每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
  * 异常情况：
    * 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；
    * 如果虚拟机栈可以动态扩展（当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈），当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。
* 本地方法栈
  * 与虚拟机栈作用基本相同，只是面向本地方法进行栈帧的管理
  * 与虚拟机栈相同，会产生StackOverflowError和OutOfMemoryError异常
* 程序计数器
  * 一块较小的内存，线程私有
  * 用途：
    * 当前线程所执行的字节码的行号指示器
    * 字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。
    * 为了线程切换，程序可以执行正确的指令，需要程序计数器来记录
  * **此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。**
* 实例说明：

```java
import java.text.SimpleDataFormat;
import java.util.Date;
import org.apache.log4j.Logger;

public class HelloWorld{
    private static Logger LOGGER = Logger.getLogger(HelloWorld.class.getName());
    public void sayHello(String Hello){
        SimpleDataFormat formatter = new SimpleDataFormat("dd.MM.YYYY");
        String today = formatter.format(new Date());
        LOGGER.info(today + " : "+messeage);
    }
}
```

​	在上面的实例中，数据在内存中的存放如下：

| 内存位置 | 存放数据                                                     |
| -------- | ------------------------------------------------------------ |
| 堆       | Object: HelloWorld<br />Object: SimpleDataFormat<br />Object: String<br />Object:Logger |
| 方法区   | Class: HelloWorld<br />Class: Logger<br />Class: SimpleDataFormat |
| JVM栈    | Parameter Ref: String "message"<br />Variable Ref: formatter<br />local primitive: "lineNo" |

---

2018-05-26更新

#### 3.垃圾回收器

由于堆中的对象和方法区中所占用的内存，既不能像程序计数器、虚拟机栈、本地方法栈都是随线程而生随线程而灭，栈帧随着方法的进入和退出做入栈和出栈操作，实现了自动的内存清理。因此，需要进行垃圾回收。

* 对象存活判断

  * **引用计数**：每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。此方法简单，无法解决对象相互循环引用的问题。

  * **可达性判断**：从GC Roots开始向下搜索，搜索所走过的路径称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。不可达对象。

    > 其中GC Root包括：
    >
    > * 虚拟机栈中引用的对象
    > * 方法区中类静态属性实体引用的对象
    > * 方法区中常量引用的对象
    > * 本地方法栈中JNI引用的对象

* 垃圾收集算法

  * 标记-清除算法
    * 首先标记需要回收的对象，然后统一回收掉所有被标记的对象
    * 后续的收集算法都是基于这种思路并对其缺点进行改进而得到的
    * 缺点：1. 效率问题，标记和清除过程的效率都不高；2. 空间问题，标记清除之后会产生大量不连续的内存碎片，会导致不能找到足够大的内存分配较大对象
  * 复制算法
    * 它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。
    * 优点：内存分配时也就不用考虑内存碎片等复杂情况
    * 缺点：将内存缩小为原来的一半，持续复制长生存期的对象则导致效率降低；可能执行较多的复制操作，影响效率
  * 标记-压缩算法
    * 首先标记需要回收的对象，然后让所有存活的对象都向一端移动，直接清理掉端边界以外的内存
    * 提高清理效率
  * 分代收集算法
    * GC分代的基本假设：绝大部分对象的生命周期都非常短暂，存活时间短。
    * “分代收集”（Generational Collection）算法，把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或“标记-整理”算法来进行回收。

* 几种垃圾收集器

  * Serial收集器
    * 串行收集器：新生代，老年代都穿行；新生代复制算法、老年代标记-压缩；稳定，效率高；可能产生较长停顿
    * ParNew：新生代并行，老年代串行；新生代复制算法、老年代标记-压缩
  * Parallel收集器
    * 类似ParNew收集器
    * 更关注系统的吞吐量
    * 动态调整这些参数以提供最合适的停顿时间或最大的吞吐量
    * 也可以通过参数控制GC的时间
    * 新生代复制算法、老年代标记-压缩
  * Parallel Old收集器
    * 老年代并行
  * CMS收集器
    * 一种以获取最短回收停顿时间为目标的收集器
    * 基于“标记-清除”算法
    * 初始标记 -> 并发标记 -> 重新标记 -> 并发清除
    * 其中初始标记、重新标记这两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC Roots Tracing的过程，而重新标记阶段则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。
    * **优点**: 并发收集、低停顿
    * **缺点**: 产生大量空间碎片、并发阶段会降低吞吐量
  * G1收集器
    * **空间整合**，G1收集器采用标记整理算法，不会产生内存空间碎片。分配大对象时不会因为无法找到连续空间而提前触发下一次GC
    * **可预测停顿**，这是G1的另一大优势，降低停顿时间是G1和CMS的共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为N毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒